[Main](../README.md)
---

# üß™ Kubernetes Probes Practice Lesson: Liveness, Readiness, Startup

## üß† Goal

Students will:
* Understand the difference between liveness, readiness, and startup probes.
* Learn how to define different probe types: httpGet, tcpSocket, exec.
* Observe how Kubernetes handles container restarts, pod availability, and traffic routing based on probes.

## üõ†Ô∏è Setup: Simple HTTP Server in Python (Flask)

Use the following code to simulate a simple server with custom endpoints for probes.

app.py
```python
from flask import Flask
import time
import os

app = Flask(__name__)
start_time = time.time()

@app.route('/healthz')
def healthz():
    return "OK", 200

@app.route('/ready')
def ready():
    if time.time() - start_time > 15:
        return "READY", 200
    return "NOT READY", 500

@app.route('/startup')
def startup():
    if time.time() - start_time > 10:
        return "STARTED", 200
    return "STARTING", 500

@app.route('/')
def index():
    return "Hello from Probe App!", 200
```

üê≥ Dockerfile
```dockerfile
FROM python:3.9-slim
WORKDIR /app
COPY app.py .
RUN pip install flask
CMD ["python", "app.py"]
```
üß™ Build and Push
```bash
docker build -t <your-dockerhub>/probe-app:latest .
docker push <your-dockerhub>/probe-app:latest
```

## üì¶ Kubernetes Deployment with Probes

probes-deployment.yaml
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: probe-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: probe-app
  template:
    metadata:
      labels:
        app: probe-app
    spec:
      containers:
      - name: probe-app
        image: <your-dockerhub>/probe-app:latest
        ports:
        - containerPort: 5000
        livenessProbe:
          httpGet:
            path: /healthz
            port: 5000
          initialDelaySeconds: 5
          periodSeconds: 5
        readinessProbe:
          httpGet:
            path: /ready
            port: 5000
          initialDelaySeconds: 5
          periodSeconds: 5
        startupProbe:
          httpGet:
            path: /startup
            port: 5000
          failureThreshold: 10
          periodSeconds: 2
```
Replace <your-dockerhub> accordingly.

## ‚úÖ Apply the Deployment
```bash
kubectl apply -f probes-deployment.yaml
```

## üîç Verification

General Pod Status
```bash
kubectl get pods
kubectl describe pod -l app=probe-app
```
Watch Events
```bash
kubectl get events --sort-by='.lastTimestamp'
```
Logs
```bash
kubectl logs -l app=probe-app
```

## ‚ö° TCP & Exec Probe Examples

### TCP Probe

Modify the livenessProbe section:
```yaml
livenessProbe:
  tcpSocket:
    port: 5000
  initialDelaySeconds: 5
  periodSeconds: 5
```
### Exec Probe

Assuming a container where a file /tmp/healthy indicates health:

Modify app to create a health file:
```python
@app.route('/break')
def break_app():
    os.remove("/tmp/healthy")
    return "App is broken", 500

@app.route('/fix')
def fix_app():
    with open("/tmp/healthy", "w") as f:
        f.write("ok")
    return "App is fixed", 200
```
Then update the container CMD:
```dockerfile
CMD ["sh", "-c", "touch /tmp/healthy && python app.py"]
```
And YAML:
```bash
livenessProbe:
  exec:
    command:
    - cat
    - /tmp/healthy
  initialDelaySeconds: 5
  periodSeconds: 5
```

## üß™ Simulate Failures

Break the readiness:
```bash
kubectl exec -it <pod> -- curl localhost:5000/break
```
‚úÖ Observe:
```bash
kubectl get pods
kubectl describe pod <pod>
```
Kubernetes will stop sending traffic to the pod but won‚Äôt restart it.

## Break liveness

Modify app so /healthz returns 500 and redeploy.

Kubernetes will restart the container.

## üßπ Cleanup
```bash
kubectl delete deployment probe-app
```

## üèÅ Bonus Task

Ask students to:
* Combine HTTP liveness, TCP readiness, and Exec startup in one deployment.
* Observe behavior with a delay (e.g. sleep 30 before startup file is created).


# üß™ Kubernetes Practice: nodeName, nodeSelector, Affinity, Anti-Affinity

## Label Nodes for Scheduling

```bash
kubectl get nodes
kubectl label nodes <node1> disk=ssd
kubectl label nodes <node2> zone=zone-a
kubectl label nodes <node2> env=prod
```
‚úÖ Check:
```bash
kubectl get nodes --show-labels
```

## Schedule Pod Using nodeName

Task: Create a pod that runs only on node1.

üìÑ pod-nodename.yaml:
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-nodename
spec:
  containers:
  - name: nginx
    image: nginx
  nodeName: <node1>
```
‚úÖ Verify:
```bash
kubectl get pod pod-nodename -o wide
```

## Use nodeSelector

Task: Schedule a pod to any node with disk=ssd.

üìÑ pod-nodeselector.yaml:
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-nodeselector
spec:
  containers:
  - name: nginx
    image: nginx
  nodeSelector:
    disk: ssd
```
‚úÖ Verify:
```bash
kubectl get pod pod-nodeselector -o wide
```

## Use Required nodeAffinity

Task: Schedule to node with zone=zone-a.

üìÑ pod-nodeaffinity.yaml:
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-nodeaffinity
spec:
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: zone
            operator: In
            values:
            - zone-a
  containers:
  - name: nginx
    image: nginx
```
‚úÖ Verify:
```bash
kubectl get pod pod-nodeaffinity -o wide
```

## Use Preferred nodeAffinity

Task: Prefer node with env=prod.

üìÑ pod-nodeaffinity-preferred.yaml:
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-nodeaffinity-pref
spec:
  affinity:
    nodeAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
      - preference:
          matchExpressions:
          - key: env
            operator: In
            values:
            - prod
        weight: 100
  containers:
  - name: nginx
    image: nginx
```
‚úÖ Verify:
```bash
kubectl get pod pod-nodeaffinity-pref -o wide
```

## Use podAffinity (Co-locate Pods)

Task:
* Create backend pod with label app: backend.
* Then schedule frontend pod that wants to be on the same node.

üìÑ backend.yaml:
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: backend
  labels:
    app: backend
spec:
  containers:
  - name: nginx
    image: nginx
```
üìÑ frontend-affinity.yaml:
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: frontend
spec:
  affinity:
    podAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchLabels:
            app: backend
        topologyKey: "kubernetes.io/hostname"
  containers:
  - name: nginx
    image: nginx
```
‚úÖ Verify:
```bash
kubectl get pods -o wide
```

## Use podAntiAffinity (Avoid Same Node)

üìÑ isolated.yaml:
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: isolated
spec:
  affinity:
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchLabels:
            app: backend
        topologyKey: "kubernetes.io/hostname"
  containers:
  - name: nginx
    image: nginx
```
‚úÖ Verify:
```bash
kubectl get pods -o wide
```

## Combine Node + Pod Affinity

Task: Deploy a pod that:
* Runs only on nodes with zone=zone-a
* Wants to be on the same node as another pod with label tier=api

üìÑ combined-affinity.yaml:
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: complex
spec:
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: zone
            operator: In
            values:
            - zone-a
    podAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchLabels:
            tier: api
        topologyKey: "kubernetes.io/hostname"
  containers:
  - name: nginx
    image: nginx
```
‚úÖ Test by deploying a pod with tier=api label.

## üßπ Cleanup
```bash
kubectl delete pod pod-nodename pod-nodeselector pod-nodeaffinity pod-nodeaffinity-pref backend frontend isolated complex
kubectl label node <node1> disk-
kubectl label node <node2> zone- env-
```

## üéÅ Bonus Exercises
* Try scheduling a pod with nodeSelector to a node without the label ‚Äî observe the pod stay Pending.
* Schedule 2 pods using podAntiAffinity with topologyKey: zone, not hostname.
* Combine preferred and required affinity types.
* Write a Deployment that only schedules on nodes with disktype=nvme.



[Main](../README.md)
---