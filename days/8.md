[Main](../README.md)
---

# Flask API for DevOps Tutorial: What is Flask and Why Use It in DevOps

## 1. Core Theory

### What is Flask?
Flask is a lightweight, micro web framework for Python that allows you to build web applications and APIs quickly and efficiently. It's designed to be simple, flexible, and easy to extend with numerous extensions.

Flask Application Components:

| Component | Purpose | Example |
|-----------|---------|---------|
| `Flask(__name__)` | Application instance | `app = Flask(__name__)` |
| **Routes** | URL endpoints | `@app.route('/health')` |
| **Configuration** | App settings | `app.config['DEBUG'] = True` |


### Task 1: Understanding Flask's Minimal Viable API
```python
# minimal_flask.py
from flask import Flask

# Create Flask application instance
app = Flask(__name__)

@app.route('/')
def hello():
    return 'Hello, DevOps!'

# Run the application
if __name__ == '__main__':
    # Development server - in production, use Gunicorn/uWSGI
    app.run(
        host='0.0.0.0',  # Listen on all interfaces (important for containers)
        port=5000,
        debug=True  # Auto-reload on code changes (development only!)
    )
```

### Request-Response Cycle in Flask

```
Client Request
    ‚Üì
URL Routing
    ‚Üì
View Function Execution
    ‚Üì
Response Generation
    ‚Üì
Client Response
```

#### Basic Route Patterns:
```python
@app.route('/health')                    # Static path
@app.route('/api/v1/deployments')        # Nested path  
@app.route('/deployments/<int:id>')      # URL parameter
@app.route('/projects/<project_name>')   # String parameter
@app.route('/users/<uuid:user_id>')      # UUID parameter
```

#### Return JSON

```python
# Basic route - health check (essential for DevOps)
@app.route('/health')
def health_check():
    return {
        'status': 'healthy',
        'timestamp': '2024-01-15T10:30:00Z',
        'version': '1.0.0'
    }

# DevOps info endpoint
@app.route('/info')
def service_info():
    return {
        'service_name': 'devops-api',
        'environment': 'development',
        'uptime': '2 hours',
        'dependencies': ['database', 'cache']
    }
```

#### Route with string parameter (GET)
https://api.dictionaryapi.dev/api/v2/entries/en/hello
```python
# Simple echo endpoint for testing
@app.route('/echo/<message>')
def echo_message(message):
    return {
        'received_message': message,
        'length': len(message),
        'uppercase': message.upper()
    }
```

#### Route with URL parameters (GET)

```python
# Route with URL parameters (GET)
@app.route('/deployments/<int:deployment_id>', methods=['GET'])
def get_deployment(deployment_id):
    # In real application, fetch from database
    deployment = {
        'id': deployment_id,
        'application': 'web-api',
        'version': '1.2.3',
        'environment': 'production',
        'status': 'completed',
    }
    
    return jsonify(deployment)
```

#### Route with multiple parameters (GET)
```python
@app.route('/environments/<env_name>/services/<service_name>', methods=['GET'])
def get_service_status(env_name, service_name):
    status = {
        'environment': env_name,
        'service': service_name,
        'status': 'running',
        'version': '2.1.0',
    }
    
    return jsonify(status)
```

#### Basic Query Parameter Handling

```python
from flask import Flask, request, jsonify

app = Flask(__name__)

@app.route('/search', methods=['GET'])
def search_users():
    try:
        # Get query parameters with defaults
        name = request.args.get('name', '')
        department = request.args.get('department', '')
        limit = request.args.get('limit', 10, type=int)
        
        # Validate input
        if limit < 1 or limit > 100:
            return jsonify({'error': 'Limit must be between 1 and 100'}), 400
            
        # Simulate search logic
        results = {
            'query': {
                'name': name,
                'department': department,
                'limit': limit
            },
            'results': [
                {'id': 1, 'name': 'John Doe', 'department': 'engineering'},
                {'id': 2, 'name': 'Jane Smith', 'department': 'engineering'}
            ],
            'total': 2
        }
        
        return jsonify(results)
    
    except Exception as e:
        return jsonify({'error': str(e)}), 500

if __name__ == '__main__':
    app.run(debug=True)
```

#### POST Methods and Request Data Handling
```python

from flask import Flask, jsonify, request
from datetime import datetime
import json
import uuid

app = Flask(__name__)

# Basic deployment creation (POST)
@app.route('/deployments', methods=['POST'])
def create_deployment():
    # Check if request contains JSON data
    if not request.is_json:
        return jsonify({'error': 'Request must be JSON'}), 400
    
    data = request.get_json()
    
    # Validate required fields
    required_fields = ['application', 'version', 'environment']
    for field in required_fields:
        if field not in data:
            return jsonify({'error': f'Missing required field: {field}'}), 400
    deployment_id = 22
    deployment = {
        'id': deployment_id,
        'application': data['application'],
        'version': data['version'],
        'environment': data['environment'],
        'status': 'created',
        'created_at': datetime.utcnow().isoformat() + 'Z',
        'created_by': data.get('user', 'api'),
        'metadata': data.get('metadata', {})
    }
    
    # Log the deployment
    print(f"üöÄ Deployment created: {deployment_id} for {deployment['application']}")
    
    return jsonify(deployment), 201

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5001, debug=True)
```

#### Combined GET/POST Routes and Advanced Routing
```python
from flask import Flask, jsonify, request, abort
from datetime import datetime
import uuid
import json

app = Flask(__name__)

# Combined GET/POST for projects resource
@app.route('/projects', methods=['GET', 'POST'])
def projects_handler():
    if request.method == 'GET':
        # GET - List all projects
        return jsonify({
            'count': len(projects),
            'projects': list(projects.values())
        })
    
    elif request.method == 'POST':
        # POST - Create new project
        if not request.is_json:
            return jsonify({'error': 'Request must be JSON'}), 400
        
        data = request.get_json()
        
        # Validate required fields
        if 'name' not in data:
            return jsonify({'error': 'Project name is required'}), 400
        
        project_name = data['name']
        
        # Check if project already exists
        if project_name in projects:
            return jsonify({'error': f'Project {project_name} already exists'}), 409
        
        # Create project
        project = {
            'name': project_name,
            'description': data.get('description', ''),
            'environments': data.get('environments', ['development']),
            'current_version': data.get('version', '1.0.0'),
            'status': 'active',
            'created_at': datetime.utcnow().isoformat() + 'Z',
            'created_by': data.get('created_by', 'api')
        }
        
        return jsonify(project), 201

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5002, debug=True)
```

#### Route Best Practices and Error Handling
```python
from flask import Flask, jsonify, request, g
from datetime import datetime
import time
import functools
import uuid

app = Flask(__name__)

# Request tracking middleware
@app.before_request
def before_request():
    """Execute before each request"""
    g.start_time = time.time()
    g.request_id = str(uuid.uuid4())[:8]
    
    # Log request
    app.logger.info(f"Request {g.request_id}: {request.method} {request.path}")

@app.after_request  
def after_request(response):
    # Calculate response time
    if hasattr(g, 'start_time'):
        response_time = (time.time() - g.start_time) * 1000  # ms
        response.headers['X-Response-Time'] = f'{response_time:.2f}ms'
    
    # Add request ID to response
    if hasattr(g, 'request_id'):
        response.headers['X-Request-ID'] = g.request_id
    
    # CORS headers (for web interfaces)
    response.headers['Access-Control-Allow-Origin'] = '*'
    response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS'
    response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization'
    
    # Log response
    app.logger.info(f"Response {g.request_id}: {response.status_code}")
    
    return response

@app.errorhandler(404)
def not_found(error):
    """Handle 404 errors consistently"""
    return jsonify({
        'error': 'Resource not found',
        'path': request.path,
        'method': request.method,
        'request_id': getattr(g, 'request_id', 'unknown')
    }), 404

@app.errorhandler(405)
def method_not_allowed(error):
    """Handle 405 errors"""
    return jsonify({
        'error': 'Method not allowed',
        'allowed_methods': error.valid_methods,
        'path': request.path,
        'method': request.method,
        'request_id': getattr(g, 'request_id', 'unknown')
    }), 405

@app.errorhandler(500)
def internal_error(error):
    """Handle 500 errors"""
    return jsonify({
        'error': 'Internal server error',
        'request_id': getattr(g, 'request_id', 'unknown')
    }), 500

if __name__ == '__main__':
    # Configure logging
    import logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    app.run(host='0.0.0.0', port=5003, debug=True)
```

#### Basic JSON Response Methods
```python
# basic_json_responses.py
"""
Basic JSON response methods in Flask
"""

from flask import Flask, jsonify, Response
import json
from datetime import datetime
import psutil

app = Flask(__name__)

# Method 1: Using jsonify() - RECOMMENDED
@app.route('/health/jsonify', methods=['GET'])
def health_jsonify():
    """Using jsonify() for automatic JSON conversion"""
    health_data = {
        'status': 'healthy',
        'timestamp': datetime.utcnow().isoformat() + 'Z',
        'service': 'devops-api',
        'version': '1.0.0',
        'checks': {
            'database': 'connected',
            'cache': 'connected',
            'storage': 'available'
        }
    }
    
    # jsonify automatically sets Content-Type to application/json
    return jsonify(health_data)

# Method 2: Using json.dumps() with Response object
@app.route('/health/response', methods=['GET'])
def health_response():
    """Using Response object for full control"""
    health_data = {
        'status': 'healthy',
        'timestamp': datetime.utcnow().isoformat() + 'Z',
        'service': 'devops-api'
    }
    
    # Convert to JSON string with custom formatting
    json_string = json.dumps(health_data, indent=2, ensure_ascii=False)
    
    # Create Response object with custom headers
    response = Response(
        response=json_string,
        status=200,
        mimetype='application/json',
        headers={
            'X-Custom-Header': 'DevOps-API',
            'X-Response-ID': '12345'
        }
    )
    
    return response

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)
```


#### Comparing Flask DevOps Approaches
```python

import subprocess
import json
from datetime import datetime

# Flask API approach for the same functionality
from flask import Flask, jsonify
import psutil  # You'd need: pip install psutil

app = Flask(__name__)

@app.route('/system/metrics')
def system_metrics():
    """System metrics API endpoint - replaces bash monitoring script"""
    try:
        # CPU usage
        cpu_percent = psutil.cpu_percent(interval=1)
        
        # Memory usage
        memory = psutil.virtual_memory()
        memory_percent = memory.percent
        
        # Disk usage
        disk = psutil.disk_usage('/')
        disk_percent = disk.percent
        
        return jsonify({
            'timestamp': datetime.utcnow().isoformat() + 'Z',
            'cpu_usage_percent': cpu_percent,
            'memory_usage_percent': memory_percent,
            'disk_usage_percent': disk_percent,
            'memory_available_gb': round(memory.available / (1024**3), 2),
            'disk_free_gb': round(disk.free / (1024**3), 2)
        })
    
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/system/processes')
def running_processes():
    """Get running processes - replaces 'ps aux' command"""
    processes = []
    for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_percent']):
        try:
            processes.append(proc.info)
        except (psutil.NoSuchProcess, psutil.AccessDenied):
            pass
    
    return jsonify({
        'count': len(processes),
        'processes': processes[:10]  # Return first 10 for demo
    })

    
    # Start the Flask app
    app.run(host='0.0.0.0', port=5001, debug=False)
```

### HTML templating
```python

from flask import Flask, request, jsonify, render_template_string
import logging
from datetime import datetime
import json
import subprocess
import os

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = Flask(__name__)

# In-memory storage for demo (use database in production)
deployments = {}
monitoring_data = {}
configurations = {}

# HTML template for dashboard
DASHBOARD_HTML = """
<!DOCTYPE html>
<html>
<head>
    <title>DevOps Control Plane</title>
</head>
<body>
    <h1>üöÄ DevOps Control Plane</h1>
    
    <h2>üìä System Status</h2>
    <p><strong>Uptime:</strong> {{ uptime }}</p>
    <p><strong>Active Deployments:</strong> {{ deployments_count }}</p>

    <h2>üîß Available Endpoints</h2>
    {% for endpoint in endpoints %}
        <strong>{{ endpoint.method }}</strong> {{ endpoint.path }}<br>
        <em>{{ endpoint.description }}</em>
    {% endfor %}
    
</body>
</html>
"""

@app.route('/')
def dashboard():
    """Main dashboard for DevOps control plane"""
    endpoints = [
        {'method': 'GET', 'path': '/deployments', 'description': 'List all deployments'},
        {'method': 'POST', 'path': '/deployments', 'description': 'Create new deployment'},
        {'method': 'GET', 'path': '/monitoring/metrics', 'description': 'System metrics'},
        {'method': 'GET', 'path': '/monitoring/alerts', 'description': 'Active alerts'},
        {'method': 'GET', 'path': '/config/current', 'description': 'Current configuration'},
        {'method': 'POST', 'path': '/config/update', 'description': 'Update configuration'},
        {'method': 'GET', 'path': '/health', 'description': 'API health check'},
        {'method': 'POST', 'path': '/webhooks/github', 'description': 'GitHub webhook handler'},
    ]
    
    return render_template_string(DASHBOARD_HTML, 
        uptime="2 hours",
        deployments_count=len(deployments),
        endpoints=endpoints
    )

@app.route('/health')
def health_check():
    """Comprehensive health check endpoint"""
    health_checks = {
        'api': 'healthy',
        'database': 'healthy',  # In real app, check actual DB connection
        'cache': 'healthy',     # In real app, check cache connection
        'external_services': 'healthy'
    }
    
    all_healthy = all(status == 'healthy' for status in health_checks.values())
    
    return jsonify({
        'status': 'healthy' if all_healthy else 'degraded',
        'timestamp': datetime.utcnow().isoformat() + 'Z',
        'checks': health_checks,
        'version': '1.0.0'
    })

    app.run(host='0.0.0.0', port=5003, debug=True)
```

#### Basic Environment Variable Setup

```python
import os
from flask import Flask, jsonify
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

app = Flask(__name__)

# Basic configuration from environment variables
app.config['DEBUG'] = os.environ.get('DEBUG', 'False').lower() == 'true'
app.config['PORT'] = int(os.environ.get('PORT', 5000))
app.config['HOST'] = os.environ.get('HOST', '0.0.0.0')

@app.route('/config')
def show_config():
    """Display safe configuration values (without secrets)"""
    config_info = {
        'debug': app.config['DEBUG'],
        'port': app.config['PORT'],
        'host': app.config['HOST'],
        'environment': os.environ.get('FLASK_ENV', 'development')
    }
    return jsonify(config_info)

@app.route('/health')
def health_check():
    """Health check endpoint using config values"""
    return jsonify({
        'status': 'healthy',
        'environment': os.environ.get('FLASK_ENV', 'development'),
        'debug_mode': app.config['DEBUG']
    })

if __name__ == '__main__':
    app.run(
        host=app.config['HOST'],
        port=app.config['PORT'],
        debug=app.config['DEBUG']
    )

```

## Telegram Bots: aiogram**

*   **`Bot` Instance:**
    ```python
    bot = Bot(token=API_TOKEN)
    ```
    This is your connection to the Telegram API. It's the object that actually sends the requests.

*   **`Dispatcher` Instance:**
    ```python
    dp = Dispatcher()
    ```
    This is the brain of your bot. It receives all updates (messages, commands, etc.) and routes them to the correct handler function.

*   **Handlers (The most important part):**
    *   These are functions that are "decorated" with `@dp.message(...)`.
    *   They define what your bot should do when it receives a specific type of message.
    *   `Command("start")` is a **filter**. It means this handler only triggers for messages that contain the `/start` command.

*   **`async` and `await`:**
    *   `async def`: Declares an **asynchronous function**. This function can be "paused" while waiting for I/O (like sending a message) and let other functions run.
    *   `await`: This is the "pause" point. It tells Python: "Go do other things while we wait for `message.answer(...)` to complete."

*   **`message.answer()` vs `message.reply()`:**
    *   `message.answer()`: Sends a message to the same chat.
    *   `message.reply()`: Sends a message that explicitly replies to the user's specific message.

---

#### **2. Finding and Starting with BotFather**

1.  Open your Telegram app.
2.  In the search bar, type `@BotFather`.
3.  Select the official BotFather bot (it will have a blue verification badge).
4.  Click **"Start"** or send the `/start` command.

You will see a list of available commands. The most important ones for us are:
*   `/newbot` - Create a new bot
*   `/mybots` - Edit your existing bots
*   `/token` - Get the token for a specific bot
*   `/deletebot` - Permanently delete a bot

---

#### **3. Step-by-Step: Creating Your First Bot**

Let's walk through the process of creating a bot called "My Practice Bot".

**Step 1: Initiate Bot Creation**
Send the `/newbot` command to BotFather.

**Step 2: Choose a Display Name**
```
BotFather: Alright, a new bot. How are we going to call it? Please choose a name for your bot.
You: My Practice Bot
```
*   This is the name that users will see in conversations and chat lists.
*   You can change this later using `/mybots`.

**Step 3: Choose a Username**
```
BotFather: Good. Now let's choose a username for your bot. It must end in `bot`. Like this, for example: TetrisBot or tetris_bot.
You: my_practice_test_bot
```
**‚ö†Ô∏è Important Rules for Usernames:**
*   Must be **unique** (no one else can have it)
*   Must end with `bot` (e.g., `my_bot`, `coolbot`, `awesome_test_bot`)
*   Can contain English letters, numbers, and underscores
*   Cannot be changed after creation

#### **5. Basic Bot Configuration via BotFather**

After creation, you can enhance your bot's profile:

*   **Set Description** (`/setdescription`):
    *   This text appears when users start a chat with your bot.
    *   *Example:* "This is a practice bot for learning Aiogram. It can echo messages and provide basic information."

*   **Set About Text** (`/setabouttext`):
    *   This text appears on your bot's profile page.
    *   *Example:* "A simple demo bot created with Python Aiogram."

*   **Set Commands** (`/setcommands`):
    *   This creates a nice menu of commands when users type `/` in the chat with your bot.
    *   BotFather will ask you to send a list in this format:
    ```
    start - Start the bot
    help - Get help
    info - Get user info
    echo - Echo a message
    ```

*   **Set Bot Profile Picture** (`/setuserpic`):
    *   Upload an image to give your bot a visual identity.

---

#### **1. What is Aiogram?**

Aiogram is a modern, fully **asynchronous** framework for the Telegram Bot API written in Python 3.7+. It allows you to create efficient and scalable Telegram bots.

**Key Advantages:**
- **100% Asynchronous:** Built on `asyncio` for high performance
- **Modern Python:** Uses type hints and modern Python features
- **Full API Coverage:** Supports all Telegram Bot API methods and types
- **Flexible:** Multiple ways to organize your code (from simple to complex)
- **Well-Structured:** Clear separation of concerns with routers, filters, and middleware

---

### **2. Core Components of Aiogram**

Let's understand the main building blocks:

*   **`Bot` Class**: 
    - Your interface to the Telegram API
    - Responsible for making requests (sending messages, photos, etc.)
    - **Instance**: `bot = Bot(token="YOUR_TOKEN")`

*   **`Dispatcher` Class**:
    - The central router that processes all incoming updates
    - Distributes updates to appropriate handlers
    - Manages middlewares, filters, and state
    - **Instance**: `dp = Dispatcher()`

*   **`Router` Class**:
    - Organizes handlers into logical groups
    - Essential for building large applications
    - **Instance**: `router = Router()`

*   **Handlers**:
    - Functions that process specific types of updates (messages, commands, callbacks)
    - Use decorators like `@router.message()`, `@router.callback_query()`

*   **Filters**:
    - Determine which handlers should process which updates
    - Examples: `Command`, `Text`, `State`, custom filters

*   **Middleware**:
    - Process updates before/after they reach handlers
    - Useful for logging, authentication, database sessions

---

#### **3. Two Methods of Receiving Updates**

##### **Method 1: Long Polling (getUpdates)**

**What is it?**
- Your bot **actively requests** updates from Telegram servers
- Sends periodic HTTP requests asking "Any new messages for me?"
- **Best for**: Development, testing, small to medium bots

**How it works:**
1. Bot calls `getUpdates` method with an `offset` parameter
2. Telegram returns new updates (messages, commands, etc.)
3. Bot processes updates and acknowledges them by increasing the offset
4. Repeat the process

**Pros:**
- Easy to set up and debug
- Works behind NAT/firewall
- No need for public IP/SSL certificate

**Cons:**
- Slight delay in message delivery
- Less efficient for high-load bots

##### **Method 2: Webhook (setWebhook)**

**What is it?**
- Telegram **pushes** updates to your bot via HTTP POST requests
- You provide a public URL where Telegram should send updates
- **Best for**: Production, high-load applications

**How it works:**
1. You configure a webhook URL: `https://yourdomain.com/webhook`
2. Telegram sends all updates to this URL as they arrive
3. Your server processes them and returns HTTP 200 OK

**Pros:**
- Instant update delivery
- More efficient for high-load scenarios
- Better resource utilization

**Cons:**
- Requires public server with SSL certificate
- More complex setup
- Not suitable for local development

---

#### **4. Simple Aiogram Code Structure**

Let's create a well-structured bot with multiple commands:

```python
import asyncio
from aiogram import Bot, Dispatcher, types

# Initialize bot and dispatcher
bot = Bot(token="YOUR_BOT_TOKEN_HERE")
dp = Dispatcher()

# Handler for any text message (echo)
@dp.message()
async def echo_message(message: types.Message):
    # Echo the user's message back
    await message.answer(f"üîÅ You said: {message.text}")

# Main function to start polling
async def main():
    logging.info("Starting bot...")
    
    # Start long polling
    await dp.start_polling(bot)

if __name__ == "__main__":
    # Run the bot
    asyncio.run(main())
```

### **What are Handlers?**
Handlers are functions that process specific types of updates from Telegram. They're the "brain" of your bot that decide what to do with each message, command, or callback.

### **Handler Types Cheat Sheet**

| Handler Type | Decorator | Processes |
|--------------|-----------|-----------|
| MessageHandler | `@router.message()` | Any message (text, photo, document, etc.) |
| CommandHandler | `@router.message(Command(...))` | Messages starting with `/` |
| CallbackHandler | `@router.callback_query()` | Button clicks from inline keyboards |
| EditedMessage | `@router.edited_message()` | Edited messages |
| ChannelPost | `@router.channel_post()` | Messages in channels |

### **Filters Cheat Sheet**

| Filter Category | Examples | Usage |
|-----------------|----------|--------|
| Command Filters | `Command("start")`, `CommandStart()` | `/start` command |
| Text Filters | `Text("hello")`, `F.text == "hi"` | Exact text matching |
| Content Types | `ContentType.TEXT`, `ContentType.PHOTO` | Message type filtering |
| State Filters | `StateFilter(Form.name)` | FSM state filtering |
| Custom Filters | `lambda message: message.text.isdigit()` | Custom logic |

### **FSM (Finite State Machine) Concepts**
- **State**: A specific step in a conversation (e.g., waiting for name, waiting for age)
- **State Storage**: Where states are stored (memory, Redis, database)
- **State Groups**: Organized collection of states


#### Commands

```python
from aiogram.filters import Command

# Handler for /start command
@dp.message(Command("start"))
async def cmd_start(message: types.Message):
    welcome_text = f"""
    üëã Hello, {message.from_user.first_name}!

    Welcome to my Aiogram bot!
    
    Available commands:
    /start - Start the bot
    /help - Get help
    /info - Get user information
    
    Try sending me a regular message!
    """
    await message.answer(welcome_text)

# Handler for /help command
@dp.message(Command("help"))
async def cmd_help(message: types.Message):
    help_text = """
    ü§ñ **Help Section**
    
    This is a simple demonstration bot built with Aiogram.
    
    **Features:**
    ‚Ä¢ Command handling
    ‚Ä¢ Keyboard support
    ‚Ä¢ Echo functionality
    ‚Ä¢ User information
    
    Send any text message to see the echo feature!
    """
    await message.answer(help_text)

# Handler for /info command
@dp.message(Command("info"))
async def cmd_info(message: types.Message):
    user = message.from_user
    info_text = f"""
    üìä **User Information:**
    
    üÜî ID: `{user.id}`
    üë§ Name: {user.first_name} {user.last_name or ''}
    üìõ Username: @{user.username or 'N/A'}
    üåê Language: {user.language_code or 'N/A'}
    """
    await message.answer(info_text)

```
---

#### Message handlers

```python
# 3. Text filter with exact match
@dp.message(Text("hello"))
async def handle_hello(message: Message):
    """Handler for exact text 'hello'"""
    await message.answer(f"üëã Hello, {message.from_user.first_name}!")

# 4. Text filter with multiple values
@dp.message(Text(["hi", "hey", "greetings"]))
async def handle_greetings(message: Message):
    """Handler for multiple greeting texts"""
    responses = ["Hello!", "Hi there!", "Hey!", "Greetings!"]
    await message.answer(random.choice(responses))

# 5. Lambda filter for numbers
@dp.message(lambda message: message.text and message.text.isdigit())
async def handle_numbers(message: Message):
    """Handler for any numeric message using lambda filter"""
    number = int(message.text)
    squared = number ** 2
    await message.answer(f"üî¢ {number}¬≤ = {squared}")

# 6. Fallback handler for any text
@dp.message()
async def handle_any_text(message: Message):
    """Catch-all handler for any text message"""
    if message.text:
        await message.answer(f"üí¨ You said: '{message.text}'\n"
                           "Try /help for more options!")
    else:
        await message.answer("üìù Please send a text message or use /help")
```

#### Content type filter
```python
# 1. Content type filters
@dp.message(Command("photo"))
async def send_photo_command(message: Message):
    """Send photo when /photo command is used"""
    await message.answer_photo(
        photo="https://picsum.photos/400/300",  # Random image
        caption="üñºÔ∏è Here's your random photo!\nUse /help for more commands"
    )

@dp.message(lambda message: message.content_type == types.ContentType.PHOTO)
async def handle_received_photo(message: Message):
    """Handle when user sends a photo"""
    await message.answer("üì∏ Nice photo! Thanks for sharing.")

@dp.message(lambda message: message.content_type == types.ContentType.DOCUMENT)
async def handle_document(message: Message):
    """Handle document messages"""
    await message.answer("üìÑ Document received!")
```

#### Inline keyboard

```python
# 2. Inline keyboard with callback handlers
def get_main_keyboard():
    """Create inline keyboard with buttons"""
    return InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text="üé≤ Roll Dice", callback_data="dice_roll")],
            [InlineKeyboardButton(text="‚ÑπÔ∏è Get Info", callback_data="user_info")],
            [InlineKeyboardButton(text="‚ùå Cancel", callback_data="cancel")]
        ]
    )

@dp.message(Command("menu"))
async def show_menu(message: Message):
    """Show inline keyboard menu"""
    await message.answer(
        "üîò Choose an option:",
        reply_markup=get_main_keyboard()
    )

# 3. Callback query handlers
@dp.callback_query(Text("dice_roll"))
async def handle_dice_roll(callback: CallbackQuery):
    """Handle dice roll button click"""
    dice_value = random.randint(1, 6)
    await callback.message.edit_text(
        f"üé≤ You rolled: {dice_value}",
        reply_markup=get_main_keyboard()
    )
    await callback.answer()

@dp.callback_query(Text("user_info"))
async def handle_user_info(callback: CallbackQuery):
    """Handle user info button click"""
    user = callback.from_user
    info_text = f"""
üë§ **User Information:**
üÜî ID: `{user.id}`
üìõ Name: {user.first_name}
üì± Username: @{user.username or 'N/A'}
    """
    await callback.message.edit_text(
        info_text,
        reply_markup=get_main_keyboard()
    )
    await callback.answer("Info displayed!")

@dp.callback_query(Text("cancel"))
async def handle_cancel(callback: CallbackQuery):
    """Handle cancel button click"""
    await callback.message.edit_text("‚ùå Operation cancelled.")
    await callback.answer()
```

#### Keyboard

```python
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton

# Create a simple keyboard
keyboard = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="/start"), KeyboardButton(text="/help")],
        [KeyboardButton(text="/info")]
    ],
    resize_keyboard=True
)

# Handler for /start command
@dp.message(Command("start"))
async def cmd_start(message: types.Message):
    welcome_text = f"""
    üëã Hello, {message.from_user.first_name}!

    Welcome to my Aiogram bot!
    
    Available commands:
    /start - Start the bot
    /help - Get help
    /info - Get user information
    
    Try sending me a regular message!
    """
    await message.answer(welcome_text, reply_markup=keyboard)
```

---

#### FSM

```python
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.context import FSMContext
from aiogram.fsm.storage.memory import MemoryStorage

# Define FSM states
class UserProfile(StatesGroup):
    """States for user profile creation"""
    waiting_for_name = State()
    waiting_for_age = State()
    waiting_for_city = State()

# Initialize with memory storage
storage = MemoryStorage()
dp = Dispatcher(storage=storage)

# 1. Start profile creation
@dp.message(Command("profile"))
async def start_profile(message: Message, state: FSMContext):
    """Start the profile creation process"""
    await state.set_state(UserProfile.waiting_for_name)
    await message.answer(
        "üë§ Let's create your profile!\n"
        "What's your name?"
    )

# 2. Handle name input
@dp.message(UserProfile.waiting_for_name)
async def process_name(message: Message, state: FSMContext):
    """Process user's name and ask for age"""
    if len(message.text) < 2:
        await message.answer("‚ùå Name must be at least 2 characters. Try again:")
        return
    
    await state.update_data(name=message.text)
    await state.set_state(UserProfile.waiting_for_age)
    await message.answer(f"üëã Nice to meet you, {message.text}!\nHow old are you?")

# 3. Handle age input
@dp.message(UserProfile.waiting_for_age)
async def process_age(message: Message, state: FSMContext):
    """Process user's age and ask for city"""
    if not message.text.isdigit():
        await message.answer("‚ùå Please enter a valid age (numbers only):")
        return
    
    age = int(message.text)
    if not (1 <= age <= 120):
        await message.answer("‚ùå Please enter a realistic age (1-120):")
        return
    
    await state.update_data(age=age)
    await state.set_state(UserProfile.waiting_for_city)
    await message.answer("üèôÔ∏è What city do you live in?")

# 4. Handle city input and complete profile
@dp.message(UserProfile.waiting_for_city)
async def process_city(message: Message, state: FSMContext):
    """Process user's city and complete profile"""
    city = message.text.strip()
    if len(city) < 2:
        await message.answer("‚ùå Please enter a valid city name:")
        return
    
    # Get all collected data
    data = await state.get_data()
    
    profile_text = f"""
‚úÖ **Profile Created!**

üìõ Name: {data['name']}
üî¢ Age: {data['age']}
üèôÔ∏è City: {city}

Thank you for completing your profile!
    """
    await message.answer(profile_text)
    await state.clear()  # Important: clear the state
```

### **Task 4: Advanced Filter Combinations**

```python
from aiogram.filters import and_f, or_f

# 1. Combined filters with AND
@router.message(
    and_f(
        Command("search"),
        lambda message: len(message.text.split()) > 1  # Has arguments
    )
)
async def handle_search_with_query(message: Message):
    """Handle /search command with query"""
    query = ' '.join(message.text.split()[1:])  # Remove "/search"
    await message.answer(f"üîç Searching for: '{query}'")

@router.message(Command("search"))
async def handle_search_no_query(message: Message):
    """Handle /search command without query"""
    await message.answer("‚ùå Please provide a search query: /search <query>")

# 2. Combined filters with OR
@router.message(
    or_f(
        Text("bye", ignore_case=True),
        Text("goodbye", ignore_case=True),
        Text("see you", ignore_case=True)
    )
)
async def handle_goodbyes(message: Message):
    """Handle various goodbye messages"""
    responses = ["üëã Goodbye!", "See you later!", "Bye! Come back soon!"]
    await message.answer(random.choice(responses))
```


#### Logging
```python
import logging

# Configure logging
logging.basicConfig(level=logging.INFO)

# Initialize bot and dispatcher
bot = Bot(token="YOUR_BOT_TOKEN_HERE")
```

---

#### **Webhook Setup**
```text
telegram_bot/
‚îú‚îÄ‚îÄ bot.py
‚îú‚îÄ‚îÄ config.py
‚îú‚îÄ‚îÄ handlers/
‚îÇ   ‚îî‚îÄ‚îÄ start.py
‚îú‚îÄ‚îÄ requirements.txt
‚îî‚îÄ‚îÄ main.py
```

#### requirements.txt
```text
aiogram==3.13.1
python-dotenv
```

#### config.py
```python
import os
from dotenv import load_dotenv

load_dotenv()

BOT_TOKEN = os.getenv("BOT_TOKEN")
NODE_ENV = os.getenv("NODE_ENV", "development")  # "development" or "production"

# Webhook settings (used in production)
WEBHOOK_URL = os.getenv("WEBHOOK_URL", "")
WEBAPP_HOST = os.getenv("WEBAPP_HOST", "0.0.0.0")
WEBAPP_PORT = int(os.getenv("WEBAPP_PORT", 8080))
```

#### handlers/start.py
```python
from aiogram import Router, types
from aiogram.filters import CommandStart

router = Router()

@router.message(CommandStart())
async def start_command(message: types.Message):
    await message.answer("üëã Hello! I‚Äôm your bot. Ready to work!")
```

#### bot.py
```python
from aiogram import Bot, Dispatcher
from config import BOT_TOKEN
from handlers import start

bot = Bot(token=BOT_TOKEN)
dp = Dispatcher()

# Include handlers
dp.include_router(start.router)
```

#### main.py
```python
import asyncio
import logging
from aiogram import types
from aiogram.webhook.aiohttp_server import SimpleRequestHandler, setup_application
from aiohttp import web
from bot import bot, dp
from config import NODE_ENV, WEBHOOK_URL, WEBAPP_HOST, WEBAPP_PORT

logging.basicConfig(level=logging.INFO)

async def on_startup():
    if NODE_ENV == "production":
        # Drop old updates and set webhook
        await bot.delete_webhook(drop_pending_updates=True)
        await bot.set_webhook(WEBHOOK_URL)
        logging.info(f"üåê Webhook set: {WEBHOOK_URL}")
    else:
        # Drop old updates when using long polling
        await bot.delete_webhook(drop_pending_updates=True)
        logging.info("ü§ñ Starting in long polling mode")

async def on_shutdown():
    await bot.session.close()
    logging.info("Bot stopped")

async def start_polling():
    await on_startup()
    await dp.start_polling(bot)

async def start_webhook():
    await on_startup()
    app = web.Application()
    SimpleRequestHandler(dispatcher=dp, bot=bot).register(app, path="/")
    setup_application(app, dp, bot=bot)

    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, WEBAPP_HOST, WEBAPP_PORT)
    logging.info(f"üöÄ Webhook server started at http://{WEBAPP_HOST}:{WEBAPP_PORT}")
    await site.start()

    while True:
        await asyncio.sleep(3600)

if __name__ == "__main__":
    if NODE_ENV == "production":
        asyncio.run(start_webhook())
    else:
        asyncio.run(start_polling())
```

#### .env
```txt
BOT_TOKEN=8207242662:AAHxe52nOTLuHOL1RA8x4Q2eBmbVxXv7vmE
NODE_ENV=production
WEBHOOK_URL=lesson-bot.zafarsaidov.uz
WEBAPP_HOST="0.0.0.0"
WEBAPP_PORT=5005
```

```
https://api.dictionaryapi.dev/api/v2/entries/en/book
```

[Main](../README.md)
---
