[Main](../README.md)
---

## Core Theory: What is Ansible?

At its core, **Ansible is an open-source automation platform** used for IT tasks such as configuration management, application deployment, intra-service orchestration, and provisioning.

Think of it as a way to **automate and document the setup and maintenance of your IT infrastructure.** Instead of manually SSH-ing into servers one by one to run commands or copy files, you write a simple, human-readable description of the desired state of those servers, and Ansible makes it happen.

### Key Architectural Principles & Facts

1.  **Agentless:** This is Ansible's most significant feature. It does **not** require any software or "agent" to be installed on the remote nodes (the servers you want to manage). It connects via SSH (on Linux/Unix) or WinRM (on Windows), uses the existing remote system's Python interpreter to run temporary modules, and then removes them when done.
    *   **Benefit:** Vastly simpler to set up and maintain. No agent version compatibility issues, no extra open ports, no performance impact on managed nodes.

2.  **Idempotency:** A core concept in Ansible. An operation is idempotent if you can perform it multiple times without changing the result beyond the initial application.
    *   **Example:** If a playbook task ensures a user `deploy` exists, running that playbook once will create the user. Running it 100 more times will not create 100 users or cause an error; it will simply check that the user exists and do nothing.
    *   **Benefit:** You can safely run your Ansible playbooks repeatedly. This makes them safe, reliable, and perfect for ensuring a system's state conforms to your specification.

3.  **Declarative (Desired State) Language:** You describe the *desired state* of the system, not the step-by-step commands to get there.
    *   **Imperative (Procedural) Approach:** "Run `useradd deploy`", then "run `usermod -aG sudo deploy`".
    *   **Ansible's Declarative Approach:** "The user `deploy` must exist and be a member of the `sudo` group." Ansible figures out the necessary commands to achieve that state.
    *   **Benefit:** Your automation code becomes more about the "what" than the "how," making it more portable and easier to understand.

4.  **Push-Based Model:** Ansible uses a "push" model, where a central control node initiates the connection to managed nodes and pushes the configuration to them. This is in contrast to a "pull" model (like some other tools) where agents on the nodes periodically check in with a central server.

5.  **Simple, Human-Readable Language (YAML):** Ansible's playbooks are written in YAML, which is designed to be easy for humans to read and write. This lowers the barrier to entry and makes automation accessible to sysadmins, developers, and DevOps engineers alike.

### Core Components

| Component | Description |
| :--- | :--- |
| **Control Node** | The machine where Ansible is installed. It's the "brain" from which you run commands and playbooks. |
| **Managed Nodes** | The servers/devices you manage. Also called "hosts." |
| **Inventory** | A file (usually `ini` or `yml`) that lists your managed nodes, often grouped (e.g., `[webservers]`, `[dbservers]`). |
| **Playbooks** | The heart of Ansible. YAML files containing a list of **plays** and **tasks** that define your automation job. |
| **Plays** | A section of a playbook that maps a set of tasks to a set of hosts. |
| **Tasks** | The individual units of action in a play (e.g., "install a package," "start a service"). |
| **Modules** | The tools in the Ansible toolkit. They are the discrete pieces of code that get executed on the remote node (e.g., `yum`, `copy`, `service`). |
| **Roles** | A pre-defined way of organizing playbooks and other files (tasks, handlers, templates) to facilitate sharing and re-use. |
| **Handlers** | Special tasks that are only triggered when notified by another task. Typically used to restart services after a configuration change. |
| **Facts** | Variables containing information about the managed node (IP, OS, RAM, etc.), gathered automatically when a playbook runs. |

**IaC Principles:**
- **Declarative**: Define the desired end state
- **Versioned**: Store configuration in version control (Git)
- **Repeatable**: Provision identical environments every time
- **Testable**: Can test infrastructure changes before applying

### How Ansible Fits In

```
[Your Laptop] → [Control Node] → [Managed Nodes]
     |                |              |
   Write            Execute        Web Servers,
 Playbooks         Playbooks      Databases, etc.
```

### When to Use Automation (And When Not To)

**✅ Perfect Use Cases:**
- Repeated tasks (user management, package installation)
- Multi-server configurations
- Complex application deployments
- Security hardening
- Disaster recovery procedures

**❌ Poor Use Cases:**
- One-time, exploratory tasks
- Tasks requiring complex human judgment
- When learning a completely new system
- Emergency "break-glass" scenarios

## The Big Picture: How Ansible Works

Ansible follows a **push-based, agentless architecture** that's fundamentally different from traditional client-server configuration management tools. Let's break down the complete flow:

```
[Developer] → [Playbook] → [Control Node] → [SSH/WinRM] → [Managed Nodes]
    |              |             |               |              |
  Write          YAML        Ansible         Connection     Execute
 Playbooks      Files       Installed        Protocol       Modules
```

> Ansible uses SSH protocol for connecting to servers

### Why YAML for Ansible?
- **Human-readable**: Easy for humans to write and understand
- **Clean syntax**: Less verbose than XML or JSON
- **Language agnostic**: Works across programming languages
- **Extensible**: Supports complex data structures

### YAML Basic Structure

#### Key Principles
1. **Whitespace matters**: Indentation defines structure (spaces, not tabs)
2. **Key-Value pairs**: `key: value`
3. **Case sensitive**: Keys are case-sensitive
4. **Documents separated by `---`**: Multiple YAML documents in one file

### YAML Data Types Cheat-Sheet

| Type | Syntax | Example |
|------|--------|---------|
| **String** | `key: value` | `name: "web server"` |
| **Number** | `key: 123` | `port: 80` |
| **Boolean** | `key: true/false` | `enabled: true` |
| **List/Array** | `- item` | `- apple`<br>`- banana` |
| **Dictionary** | `key: subkey: value` | `server: name: web1` |
| **Multi-line String** | `\|` or `>` | `description: \|`<br>`Multiple lines` |
| **Null** | `key: null` or `key: ~` | `optional: null` |

### YAML Syntax Elements

#### 1. Basic Key-Value Pairs
```yaml
# Simple key-value
name: "Apache Web Server"
port: 80
enabled: true
```

#### 2. Lists/Arrays
```yaml
# Simple list
fruits:
  - apple
  - banana
  - orange

# Inline list
fruits: [apple, banana, orange]
```

#### 3. Dictionaries/Maps
```yaml
# Nested dictionary
server:
  name: web01
  ip: 192.168.1.10
  services:
    - nginx
    - mysql
```

#### 4. Multi-line Strings
```yaml
# Preserve newlines (|)
config: |
  server {
    listen 80;
    server_name example.com;
  }

# Fold newlines (>)
description: >
  This is a long description
  that will be folded into
  a single line.
```

#### 5. Complex Data Structures
```yaml
# List of dictionaries
servers:
  - name: web01
    ip: 192.168.1.10
    role: frontend
  - name: db01
    ip: 192.168.1.20
    role: database

# Dictionary with mixed types
website:
  domain: example.com
  ports: [80, 443]
  ssl: true
  redirects:
    - from: /old
      to: /new
```

### Understanding Installation Methods

Ansible can be installed on Linux through several methods, each with different trade-offs:

#### Package Manager Installation
- **Pros**: Easy, managed updates, dependency resolution
- **Cons**: Might not have latest version
- **Supported**: Ubuntu/Debian (apt), RHEL/CentOS (yum/dnf), Fedora (dnf)

#### PIP Installation (Python Package Index)
- **Pros**: Latest version, flexible environments
- **Cons**: Manual dependency management, potential conflicts
- **Use Case**: Development, cutting-edge features

#### Source Installation
- **Pros**: Absolute control, development contributions
- **Cons**: Manual everything, complex maintenance
- **Use Case**: Ansible core development


### System Requirements

| Component | Minimum Requirement | Recommended |
|-----------|---------------------|-------------|
| **Python** | 3.8+ | 3.9+ |
| **RAM** | 512MB | 2GB+ |
| **Storage** | 100MB | 1GB+ |
| **OS** | RHEL 8+, Ubuntu 18.04+, Debian 10+ | Latest LTS |


### Installation Methods Cheat-Sheet

| Method | Command | Best For |
|--------|---------|----------|
| **Ubuntu/Debian (apt)** | `sudo apt update && sudo apt install ansible` | Production systems |
| **RHEL/CentOS (dnf)** | `sudo dnf install ansible` | Enterprise environments |
| **PIP (system)** | `pip3 install ansible` | Latest features |
| **PIP (user)** | `pip3 install --user ansible` | No root access |
| **Virtual Environment** | `python3 -m venv ansible-env && source ansible-env/bin/activate && pip install ansible` | Development, isolation |

### Post-Installation Verification

```bash
# Verify installation
ansible --version

# Check Python path
ansible --version | grep "python version"

# Test basic functionality
ansible localhost -m ping
```

### Task 3: PIP Installation with Virtual Environment

```bash
# Step 1: Install Python3 and virtual environment packages
sudo apt update
sudo apt install -y python3 python3-pip python3-venv

# Step 2: Create and activate virtual environment
python3 -m venv ~/ansible-venv
source ~/ansible-venv/bin/activate

# Step 3: Upgrade pip
pip install --upgrade pip

# Step 4: Install Ansible
pip install ansible

# Step 5: Verify installation
ansible --version

# Note: Always activate the environment before using Ansible
# source ~/ansible-venv/bin/activate
```

## Inventory (The "Address Book")

**Definition**: A file or dynamic source that lists all managed nodes, organized into groups.

**Static Inventory Example** (`inventory.ini`):
```ini
# Simple host list
web1.example.com ansible_host=10.0.0.2 ansible_user=root ansible_ssh_private_key_file=./file
web2.example.com
db-server.example.com:2222  # Custom SSH port

# Groups
[webservers]
web1.example.com
web2.example.com

[databases]
db-server.example.com

[development]
dev-web[01:03].example.com  # Pattern matching

# Group variables
[webservers:vars]
ansible_user=deploy
http_port=80

# Nested groups
[us_servers:children]
webservers
databases
```

### Modules (The "Tools")

**Definition**: Discrete units of code that execute specific tasks on managed nodes.

**Module Execution Flow**:
1. Control node copies module to remote node
2. Executes module with arguments
3. Module returns JSON result
4. Temporary files cleaned up

**Module Structure**:
```yaml
- name: Ensure nginx is installed
  package:           # Module name
    name: nginx      # Module parameter
    state: present   # Module parameter
  become: yes        # Task directive
```

### Playbooks (The "Orchestration")

**Definition**: YAML files containing a set of plays and tasks that define your automation workflow.

**Playbook Anatomy**:
```yaml
---
- name: Configure web server        # Play 1
  hosts: webservers                 # Target hosts
  become: yes                       # Privilege escalation
  vars:                             # Variables
    http_port: 80
    admin_email: admin@example.com
  
  tasks:                            # Task list
    - name: Ensure nginx is installed
      package:
        name: nginx
        state: present
    
    - name: Start nginx service
      service:
        name: nginx
        state: started
        enabled: yes

- name: Configure database server   # Play 2
  hosts: databases
  become: yes
  tasks:
    # ... database tasks
```

### Task 4: Create Basic Inventory and Test

```bash
# Create project directory
mkdir ~/ansible-lab && cd ~/ansible-lab

# Create a simple inventory file
cat > inventory.ini << EOF
[local]
localhost ansible_connection=local

[webservers]
# Example - replace with your actual servers
# web1.example.com ansible_user=ubuntu
# web2.example.com ansible_user=centos

[all:vars]
ansible_python_interpreter=/usr/bin/python3
EOF

# Test connectivity to localhost
ansible -i inventory.ini local -m ping

# Gather facts from localhost
ansible -i inventory.ini local -m setup | head -20
```

### Task 5: First Playbook Execution

```bash
# Create your first playbook
cat > first-playbook.yml << EOF
---
- name: My First Playbook
  hosts: local
  become: no
  tasks:
    - name: Display a welcome message
      debug:
        msg: "Hello from Ansible! We're running on {{ ansible_hostname }}"
    
    - name: Show OS information
      debug:
        msg: "This is {{ ansible_distribution }} {{ ansible_distribution_version }}"
    
    - name: Create a test file
      copy:
        content: "This file was created by Ansible\n"
        dest: /tmp/ansible-test-file.txt
      become: yes
EOF

# Run the playbook
ansible-playbook -i inventory.ini first-playbook.yml
```

### Ad-Hoc Command Structure

```
ansible [pattern] -m [module] -a "[arguments]" [options]
```

**Components**:
- **Pattern**: Which hosts to target (`all`, `webservers`, specific host)
- **Module** (`-m`): What action to perform (`ping`, `shell`, `copy`, etc.)
- **Arguments** (`-a`): Parameters for the module
- **Options**: Additional settings (`-i`, `-b`, `-k`, etc.)

### Essential Modules for Ad-Hoc Commands

| Module | Purpose | Example |
|--------|---------|---------|
| `ping` | Test connectivity | `ansible all -m ping` |
| `shell` | Execute shell commands | `ansible all -m shell -a "uptime"` |
| `command` | Execute commands (safer) | `ansible all -m command -a "date"` |
| `copy` | Copy files | `ansible web -m copy -a "src=file.txt dest=/tmp/"` |
| `file` | Manage files/dirs | `ansible all -m file -a "path=/tmp/test state=directory"` |
| `service` | Manage services | `ansible web -m service -a "name=nginx state=started"` |
| `package` | Install packages | `ansible all -m package -a "name=htop state=present"` |

### Targeting Patterns Cheat-Sheet

| Pattern | Meaning | Example |
|---------|---------|---------|
| `all` | All hosts in inventory | `ansible all -m ping` |
| `group` | Hosts in specific group | `ansible webservers -m ping` |
| `host` | Single host | `ansible server1 -m ping` |
| `*` | Wildcard pattern | `ansible "web*" -m ping` |
| `:&` | Intersection (AND) | `ansible "webservers:&production" -m ping` |
| `:!` | Exclusion (NOT) | `ansible "all:!database" -m ping` |

### Common Options Cheat-Sheet

| Option | Purpose | Example |
|--------|---------|---------|
| `-i` | Specify inventory file | `ansible all -i my_inventory -m ping` |
| `-b` | Become (sudo) | `ansible all -b -m package -a "name=nginx state=present"` |
| `-k` | Ask for SSH password | `ansible all -k -m ping` |
| `-K` | Ask for become password | `ansible all -b -K -m package -a "name=nginx"` |
| `-u` | SSH user | `ansible all -u admin -m ping` |
| `--become-user` | Become specific user | `ansible all -b --become-user=appuser -m command -a "whoami"` |
| `-f` | Number of parallel processes | `ansible all -f 10 -m ping` |
| `-v` | Verbose output | `ansible all -v -m ping` |

---

### Task 1: Basic Connectivity Testing
```bash
# Test connectivity to all hosts
ansible -i inventory.ini all -m ping

# Test specific group
ansible -i inventory.ini webservers -m ping

# Test single host
ansible -i inventory.ini localhost -m ping

# With verbose output to see details
ansible -i inventory.ini all -m ping -v
```

### Task 2: System Information Gathering
```bash
# Check hostname
ansible -i inventory.ini all -m command -a "hostname"

# Check uptime
ansible -i inventory.ini all -m shell -a "uptime"

# Check disk space
ansible -i inventory.ini all -m shell -a "df -h"

# Check memory usage
ansible -i inventory.ini all -m shell -a "free -h"

# Check OS version
ansible -i inventory.ini all -m shell -a "cat /etc/os-release"
```

### Task 3: File and Directory Operations
```bash
# Create a directory (requires become/sudo)
ansible -i inventory.ini all -b -m file -a "path=/tmp/ansible-test state=directory mode=0755"

# Create a file with content
ansible -i inventory.ini all -b -m copy -a "content='Hello from Ansible' dest=/tmp/ansible-test/welcome.txt"

# Check if file exists
ansible -i inventory.ini all -m stat -a "path=/tmp/ansible-test/welcome.txt"

# View file content
ansible -i inventory.ini all -m shell -a "cat /tmp/ansible-test/welcome.txt"

# Change file permissions
ansible -i inventory.ini all -b -m file -a "path=/tmp/ansible-test/welcome.txt mode=0644 owner=root"
```

### Task 4: Package and Service Management
```bash
# Check if package is installed (using appropriate module)
# For Debian/Ubuntu:
ansible -i inventory.ini all -b -m apt -a "name=curl state=present" --check

# For RHEL/CentOS:
# ansible -i inventory.ini all -b -m yum -a "name=curl state=present" --check

# Check service status
ansible -i inventory.ini all -b -m service -a "name=ssh state=started" --check

# Restart a service (if you have nginx installed)
# ansible -i inventory.ini all -b -m service -a "name=nginx state=restarted"
```

#### Advanced Structure (for large projects)
```
ansible-enterprise/
├── inventory/
│   ├── group_vars/
│   │   ├── dbs
│   │   └── k8s
│   ├── host_vars/
│   │   ├── localhost
│   │   └── db01
│   └── hosts
├── playbooks/
│   └── first.yml
└── ansible.cfg
```

#### Special Variables Cheat-Sheet
| Variable | Purpose | Example |
|----------|---------|---------|
| `ansible_host` | IP/hostname to connect | `192.168.1.10` |
| `ansible_port` | SSH port | `2222` |
| `ansible_user` | SSH user | `ubuntu` |
| `ansible_ssh_private_key_file` | SSH key path | `~/.ssh/key.pem` |
| `ansible_connection` | Connection type | `ssh`, `winrm`, `docker` |
| `ansible_become` | Use sudo | `yes` |
| `ansible_become_user` | Sudo to user | `root` |


### Task 5: Test and Validate Inventory
```bash
# Test inventory parsing
echo "=== Testing INI Inventory ==="
ansible-inventory -i inventory.ini --list

echo -e "\n=== Inventory Graph ==="
ansible-inventory -i inventory.ini --graph

```

### What is ansible.cfg?

**Definition**: `ansible.cfg` is Ansible's configuration file that controls runtime behavior, default settings, and connection parameters. It allows you to customize how Ansible operates without needing to specify command-line options repeatedly.

### Configuration File Precedence

Ansible looks for configuration files in this order (first found wins):

1. `ANSIBLE_CONFIG` (environment variable)
2. `ansible.cfg` (in current directory)
3. `~/.ansible.cfg` (in home directory)
4. `/etc/ansible/ansible.cfg` (global configuration)

### Configuration File Structure

https://docs.ansible.com/projects/ansible/latest/reference_appendices/config.html

#### Configuration in Use

```ini
[defaults]
timeout = 60
ansible_path = /home/username/git_projects/proxima/proxima/proxima_collections/tools
inventory = /home/username/git_projects/proxima/proxima/proxima_collections/tools/inventory
roles_path = /home/username/git_projects/proxima/proxima/proxima_collections/tools/roles
log_path = /home/username/git_projects/proxima/proxima/proxima_collections/tools/logs/main.log

host_key_checking = False
# private_key_file = /config/workspace/.ssh/id_rsa
# remote_user = root
interpreter_python = /usr/bin/python3

# hash_behaviour = replace
strategy = linear

; vault_password_file = ./.ansible-vault.txt

forks = 25

[ssh_connection]
pipelining = True
```

#### Example Configuration

```ini
# ansible.cfg - Basic structure
[defaults]
# General settings
host_key_checking = False
inventory = inventories/production
remote_user = admin

[inventory]
# Inventory-related settings
enable_plugins = host_list, script, auto, yaml

[privilege_escalation]
# Become/sudo settings
become = True
become_method = sudo
become_user = root
become_ask_pass = False

[ssh_connection]
# SSH settings
pipelining = True
ssh_args = -o ControlMaster=auto -o ControlPersist=60s
control_path = ~/.ansible/cp/ansible-ssh-%%h-%%p-%%r

[persistent_connection]
# Connection persistence
connect_timeout = 30
command_timeout = 30

[colors]
# Output coloring
highlight = white
verbose = blue
warn = bright purple
error = red
```

### Key Configuration Sections Cheat-Sheet

#### [defaults] Section
| Setting | Purpose | Common Values |
|---------|---------|---------------|
| `inventory` | Default inventory file | `inventories/production` |
| `remote_user` | SSH user | `ubuntu`, `centos` |
| `private_key_file` | SSH key path | `~/.ssh/ansible_key` |
| `host_key_checking` | SSH host key verification | `False` |
| `gathering` | Fact gathering | `smart`, `implicit`, `explicit` |
| `fact_caching` | Fact caching backend | `jsonfile`, `redis`, `memory` |
| `stdout_callback` | Output format | `yaml`, `json`, `debug` |
| `bin_ansible_callbacks` | Enable callbacks | `True` |
| `forks` | Parallel processes | `5`, `10`, `20` |
| `timeout` | SSH timeout | `10`, `30`, `60` |

#### [privilege_escalation] Section
| Setting | Purpose | Common Values |
|---------|---------|---------------|
| `become` | Enable privilege escalation | `True`, `False` |
| `become_method` | Escalation method | `sudo`, `su`, `pbrun` |
| `become_user` | Target user | `root`, `admin` |
| `become_ask_pass` | Prompt for password | `False` |
| `become_exe` | Custom become executable | `/usr/bin/sudo` |

#### [ssh_connection] Section
| Setting | Purpose | Common Values |
|---------|---------|---------------|
| `pipelining` | SSH pipelining | `True` |
| `ssh_args` | SSH arguments | `-o ControlMaster=auto` |
| `control_path` | Control socket path | `~/.ansible/cp/%%h-%%p-%%r` |
| `scp_if_ssh` | Use SCP for file transfer | `True` |
| `retries` | Connection retries | `3` |

#### [inventory] Section
| Setting | Purpose | Common Values |
|---------|---------|---------------|
| `enable_plugins` | Active inventory plugins | `host_list, script, yaml` |
| `cache` | Enable inventory caching | `True` |
| `cache_plugin` | Caching backend | `jsonfile`, `redis` |
| `cache_timeout` | Cache timeout | `300` |


## 2. Practice Tasks: Hands-on Exercises

### Task 1: Create Basic Project Configuration
```ini
[defaults]
# Basic settings
inventory = inventories/production
host_key_checking = False
remote_user = ubuntu
private_key_file = ~/.ssh/ansible_key
timeout = 30

# Performance settings
forks = 10
gathering = smart
fact_caching = jsonfile
fact_caching_connection = ~/.ansible/facts
fact_caching_timeout = 3600

# Output settings
stdout_callback = yaml
bin_ansible_callbacks = True
display_skipped_hosts = False
display_args_to_stdout = False

[inventory]
# Inventory settings
enable_plugins = host_list, script, auto, yaml
cache = True
cache_plugin = jsonfile
cache_timeout = 300

[privilege_escalation]
# Become settings
become = True
become_method = sudo
become_user = root
become_ask_pass = False

[ssh_connection]
# SSH optimization
pipelining = True
ssh_args = -o ControlMaster=auto -o ControlPersist=60s -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no
control_path = ~/.ansible/cp/ansible-ssh-%%h-%%p-%%r
retries = 3

[persistent_connection]
# Connection settings
connect_timeout = 30
command_timeout = 30

[colors]
# Output colors
highlight = white
verbose = blue
warn = bright purple
error = red
debug = dark gray
deprecate = purple
skip = cyan
unreachable = red
ok = green
changed = yellow
diff_add = green
diff_remove = red
diff_lines = cyan
```

[Main](../README.md)
---