[Main](../README.md)
---

# Ansible Practice Lessons: Managing Variables & Precedence

## 1. Core Theory

### Variable Precedence Hierarchy
Variables in Ansible follow a specific order of precedence (highest to lowest):

```
1. Command line values (--extra-vars)
2. Role defaults (defined in role/defaults/main.yml)
3. Inventory variables (group_vars, host_vars)
4. Playbook variables (vars: section)
5. Role variables (defined in role/vars/main.yml)
6. Block variables (only for tasks in block)
7. Task variables (vars: in task)
8. Registered variables
9. Set_facts
10. Include variables
11. Role and include params
```

### Key Concepts

**Role Defaults**: Lowest priority, meant for default values that can be easily overridden
**Role Variables**: Higher priority than playbook variables, meant for role-specific values
**Inventory Variables**: Specific to hosts/groups in inventory
**Extra Vars**: Highest priority, override everything

### Cheat Sheet
```yaml
# Role defaults (lowest priority)
# roles/myrole/defaults/main.yml
app_port: 8080
debug_mode: false

# Role variables (medium priority)
# roles/myrole/vars/main.yml
app_name: "myapplication"

# Playbook variables
# playbook.yml
vars:
  app_port: 9000  # Overrides role default

# Command line (highest priority)
ansible-playbook playbook.yml --extra-vars "app_port=3000"
```

## 2. Practice Tasks

### Task 1: Basic Variable Precedence
```yaml
# File structure:
# roles/webapp/defaults/main.yml
# roles/webapp/vars/main.yml
# playbook.yml
# inventory
# group_vars/all.yml

# Task: Create this structure and observe precedence
```

**Step-by-step instructions:**
1. Create role structure:
```bash
mkdir -p roles/webapp/{defaults,tasks,vars}
touch roles/webapp/defaults/main.yml
touch roles/webapp/vars/main.yml
touch roles/webapp/tasks/main.yml
touch playbook.yml
mkdir -p group_vars
touch group_vars/all.yml
```

2. Populate role defaults:
```yaml
# roles/webapp/defaults/main.yml
app_port: 8080
app_name: "default_app"
debug: false
database_host: "localhost"
```

3. Populate role variables:
```yaml
# roles/webapp/vars/main.yml
app_name: "role_var_app"
max_connections: 100
```

4. Create playbook:
```yaml
# playbook.yml
- hosts: localhost
  connection: local
  vars:
    app_port: 9000
    debug: true
  roles:
    - role: webapp
      vars:
        app_name: "playbook_role_var_app"
```

5. Create group variables:
```yaml
# group_vars/all.yml
database_host: "db-server.example.com"
```

6. Create role tasks:
```yaml
# roles/webapp/tasks/main.yml
- name: Display all variables
  debug:
    msg: |
      app_port: {{ app_port }}
      app_name: {{ app_name }}
      debug: {{ debug }}
      database_host: {{ database_host }}
      max_connections: {{ max_connections }}
```

7. Run and observe:
```bash
ansible-playbook playbook.yml
# Observe which values take precedence
```

### Task 2: Command Line Overrides
```bash
# Override specific variables
ansible-playbook playbook.yml --extra-vars "app_port=3000 debug=false"

# Use JSON for complex overrides
ansible-playbook playbook.yml --extra-vars '{"app_port": 4000, "app_name": "cmd_app"}'
```

### Task 3: Inventory Variables
```yaml
# host_vars/localhost.yml
app_port: 7000
environment: "development"

# Run again and observe
ansible-playbook playbook.yml
```

### Task 4: set_fact vs vars
```yaml
# Add to tasks/main.yml
- name: Set fact variable
  set_fact:
    dynamic_var: "This is set dynamically"
    
- name: Register variable
  command: echo "registered_value"
  register: cmd_output
  
- name: Use registered variable
  debug:
    msg: "Registered: {{ cmd_output.stdout }}"
```

## 3. Real-World Use Cases

### Use Case 1: Environment-Specific Configurations
```yaml
# group_vars/production.yml
app_port: 80
debug: false
database_host: "prod-db-cluster"
ssl_enabled: true

# group_vars/development.yml  
app_port: 8080
debug: true
database_host: "localhost"
ssl_enabled: false

# roles/app/defaults/main.yml
app_port: 3000
debug: true
database_host: "default-db"
ssl_enabled: false
```

### Use Case 2: Multi-Tier Application
```yaml
# playbook.yml
- hosts: webservers
  vars:
    node_type: "web"
    app_port: 80
  roles:
    - app_server

- hosts: databases
  vars:
    node_type: "database"
    app_port: 5432
  roles:
    - database_server

- hosts: load_balancers
  vars:
    node_type: "lb"
  roles:
    - load_balancer
```

### Use Case 3: Conditional Variables
```yaml
# roles/monitoring/defaults/main.yml
monitoring_enabled: true
alert_threshold: 80
notify_email: "admin@company.com"

# In playbook for specific environment
- hosts: staging
  vars:
    monitoring_enabled: false  # Disable for staging
    
- hosts: production
  vars:
    alert_threshold: 90  # Higher threshold for production
    notify_email: "prod-alerts@company.com"
```

## 4. Homework Assignments

### Assignment 1: Variable Precedence Mapping
Create a comprehensive test that demonstrates each level of variable precedence. Document the expected outcome for each scenario.

**Requirements:**
- Create at least 8 different variable definitions at different precedence levels
- Use a debug task to show final values
- Write explanations for why each variable takes precedence

### Assignment 2: Dynamic Configuration System
Build a role that:
- Uses defaults for development
- Allows environment-specific overrides
- Supports command-line customization
- Implements conditional logic based on variable values

### Assignment 3: Variable Validation
Create a playbook that:
- Validates variable types and values
- Provides sensible defaults when variables are missing
- Shows error messages for invalid configurations

## 5. Q&A

### Q1: When should I use role defaults vs role variables?
**A:** Use role defaults for values that should be easily overridden. Use role variables for values that are essential to the role's function and shouldn't be changed casually.

### Q2: How do group_vars and host_vars interact?
**A:** host_vars have higher precedence than group_vars. Within groups, more specific groups have higher precedence than less specific ones.

### Q3: Can I change the variable precedence order?
**A:** No, the precedence order is fixed in Ansible's design. You need to structure your variables according to this hierarchy.

### Q4: What's the difference between vars and set_fact?
**A:** vars are defined statically, while set_fact can set variables dynamically during playbook execution based on task results or conditions.

### Q5: How do I handle sensitive variables?
**A:** Use Ansible Vault for sensitive data. You can still leverage precedence by having vault-encrypted files in group_vars or host_vars.

## 6. Best Practices & Troubleshooting

### Best Practices

1. **Use Meaningful Defaults**: Always provide sensible defaults in role defaults
2. **Document Variables**: Clearly document what each variable does and where it can be overridden
3. **Consistent Naming**: Use consistent naming conventions across your codebase
4. **Environment Separation**: Keep different environment configurations separate
5. **Minimal Overrides**: Only override variables when necessary

### Troubleshooting Common Issues

**Problem**: Variable not taking expected value
**Solution**: Use `-v` flag to see which variable file is being loaded and in what order

**Problem**: Undefined variable errors
**Solution**: Ensure variables are defined in the correct precedence level or provide defaults

**Problem**: Variable type conflicts
**Solution**: Be consistent with variable types (string vs integer vs boolean)

**Debugging Command**:
```bash
ansible-playbook playbook.yml -v --extra-vars "debug_vars=true"
```

### Variable Debugging Template
```yaml
- name: Debug variable precedence
  debug:
    msg: |
      Variable Trace for {{ inventory_hostname }}:
      - Role Default: {{ role_default_var | default('NOT SET') }}
      - Role Var: {{ role_var | default('NOT SET') }}
      - Playbook Var: {{ playbook_var | default('NOT SET') }}
      - Inventory Var: {{ inventory_var | default('NOT SET') }}
      - Final Value: {{ final_var }}
```

# Using block, rescue, and always

## 1. Core Theory

### What are Blocks?
Blocks are logical groupings of tasks that allow you to:
- Treat multiple tasks as a single unit
- Apply common directives (when, become, etc.) to all tasks in the block
- Implement error handling with rescue and always sections

### Block Structure
```yaml
- block:
    - name: Task 1
      # ... task definition
    
    - name: Task 2
      # ... task definition
  
  rescue:
    - name: Rescue task
      # ... runs only if block fails
  
  always:
    - name: Always task
      # ... runs regardless of block success/failure
```

### Key Facts
- **Block**: Main tasks to execute
- **Rescue**: Runs only if ANY task in block fails
- **Always**: Runs regardless of block success/failure
- **Error Handling**: If rescue fails, playbook stops
- **Variable Scope**: Variables set in block are available in rescue/always


### Cheat Sheet
```yaml
# Basic Block Structure
- block:
    - task1
    - task2
  rescue:
    - rescue_task
  always:
    - cleanup_task

# With Common Directives
- block:
    - task1
    - task2
  when: condition
  become: yes
  rescue:
    - rescue_task

# Nested Blocks
- block:
    - block:
        - inner_task
      rescue:
        - inner_rescue

# Error Handling Control
- block:
    - task
  rescue:
    - rescue_task
  always:
    - cleanup_task
  ignore_errors: yes  # Continue even if rescue fails
```

### Task 1: Basic Error Handling
```yaml
---
- name: Practice Block/Rescue/Always
  hosts: localhost
  connection: local
  gather_facts: false
  
  tasks:
    - name: Basic block with simulated failure
      block:
        - name: Create temporary directory
          ansible.builtin.file:
            path: /tmp/test_block
            state: directory
          register: dir_result
        
        - name: Simulate task failure
          ansible.builtin.command: /bin/false
          when: dir_result is changed
        
        - name: This task won't run if previous fails
          ansible.builtin.debug:
            msg: "This only shows if all block tasks succeed"
      
      rescue:
        - name: Handle block failure
          ansible.builtin.debug:
            msg: "Block failed! Handling error..."
        
        - name: Show error details
          ansible.builtin.debug:
            msg: |
              Failed task: {{ ansible_failed_task.name }}
              Failed result: {{ ansible_failed_result }}
      
      always:
        - name: Cleanup temporary directory
          ansible.builtin.file:
            path: /tmp/test_block
            state: absent
          when: dir_result is changed
        
        - name: Always runs regardless
          ansible.builtin.debug:
            msg: "This always executes, success or failure"
```

### What are Handlers?
Handlers are special tasks that run only when notified by other tasks. They are typically used for service restarts, reloads, and other actions that should only occur when changes are made.

### Handler Execution Flow
```
┌─────────────────┐    notify    ┌──────────────────┐
│ Regular Task    │─────────────▶│   Handler Task   │
│ (changed: true) │              │ (queued to run)  │
└─────────────────┘              └──────────────────┘
                                       │
┌─────────────────┐    notify         │
│ Another Task    │───────────────────┘
│ (changed: true) │                   
└─────────────────┘                   
                                       ▼
                                ┌──────────────────┐
                                │ Handler Executes │
                                │ (at play end)    │
                                └──────────────────┘
```

### Key Concepts

**Notification**: Triggering a handler from a task using `notify`
**Handler**: The actual task that runs in response to notification
**Flushing**: Handlers run at the end of each play by default
**Multiple Notifications**: Handler runs only once even if notified multiple times
**Listeners**: Handlers that can be triggered by multiple names

### Cheat Sheet

```yaml
# Basic Handler Definition
handlers:
  - name: restart nginx
    service:
      name: nginx
      state: restarted

  - name: reload nginx
    service:
      name: nginx
      state: reloaded

# Task Notifying Handler
- name: Update nginx config
  template:
    src: nginx.conf.j2
    dest: /etc/nginx/nginx.conf
  notify: restart nginx

# Multiple Notifications
- name: Configure multiple services
  template:
    src: "{{ item.src }}"
    dest: "{{ item.dest }}"
  loop:
    - { src: 'app.conf.j2', dest: '/etc/app.conf' }
    - { src: 'db.conf.j2', dest: '/etc/db.conf' }
  notify:
    - restart app
    - restart db

# Using listen for multiple triggers
handlers:
  - name: restart services
    service:
      name: "{{ item }}"
      state: restarted
    listen: "restart multiple services"

# Force handler execution
- meta: flush_handlers
```

### What are Jinja2 Templates?
Jinja2 is a modern and designer-friendly templating language for Python, used by Ansible to generate dynamic configuration files. Templates allow you to create files with placeholders that get replaced with actual values during playbook execution.

### Template Processing Flow
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│ Template File   │    │ Ansible         │    │ Rendered File   │
│ (.j2) with      │───▶│ Template Module │───▶│ with actual     │
│ Variables       │    │ + Variables     │    │ values          │
│ {{ variable }}  │    │                 │    │ substituted     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### Key Jinja2 Syntax Elements

**Variables**: `{{ variable_name }}`
**Expressions**: `{{ list_var[0] }}`, `{{ dict_var.key }}`
**Conditionals**: `{% if condition %}...{% endif %}`
**Loops**: `{% for item in list %}...{% endfor %}`
**Filters**: `{{ variable | filter }}`
**Comments**: `{# comment #}`

### Cheat Sheet

```jinja2
{# Basic Variable Substitution #}
server_name {{ domain_name }};
port {{ app_port }};

{# Conditional Blocks #}
{% if environment == "production" %}
log_level error;
{% else %}
log_level debug;
{% endif %}

{# Loops #}
{% for server in backend_servers %}
server {{ server.ip }}:{{ server.port }};
{% endfor %}

{# Filters #}
{{ database_host | upper }}
{{ user_list | join(",") }}
{{ config_string | quote }}

{# Including other templates #}
{% include 'common/header.j2' %}

{# Macros for reusable components #}
{% macro service_entry(name, port) %}
service {{ name }} {
    port {{ port }};
}
{% endmacro %}

{# Using the macro #}
{{ service_entry("web", 80) }}
{{ service_entry("api", 8080) }}
```

### Use Case 1: Nginx Virtual Host Template
```jinja2
{# nginx-vhost.j2 - Production nginx virtual host #}
# Ansible Managed - DO NOT EDIT
# Virtual Host: {{ server_name }}

server {
    {% if ssl_enabled %}
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    
    ssl_certificate {{ ssl_cert_path }};
    ssl_certificate_key {{ ssl_key_path }};
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;
    {% else %}
    listen 80;
    listen [::]:80;
    {% endif %}
    
    server_name {{ server_name }};
    root {{ document_root }};
    index index.html index.htm index.php;
    
    access_log /var/log/nginx/{{ server_name }}_access.log;
    error_log /var/log/nginx/{{ server_name }}_error.log;
    
    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header X-Content-Type-Options "nosniff" always;
    
    # PHP handling
    location ~ \.php$ {
        include snippets/fastcgi-php.conf;
        fastcgi_pass unix:/var/run/php/php{{ php_version }}-fpm.sock;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
    }
    
    # Static assets caching
    location ~* \.(jpg|jpeg|png|gif|ico|css|js)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
    
    # Deny access to hidden files
    location ~ /\. {
        deny all;
        access_log off;
        log_not_found off;
    }
    
    {% if basic_auth_enabled %}
    # Basic authentication
    auth_basic "Restricted Area";
    auth_basic_user_file /etc/nginx/.htpasswd_{{ server_name }};
    {% endif %}
    
    {% if redirect_www %}
    # WWW redirect
    server_name www.{{ server_name }};
    return 301 https://{{ server_name }}$request_uri;
    {% endif %}
}
```

**Template: loadbalancer.j2**
```jinja2
{# loadbalancer.j2 - Complex template with error handling #}
# Load Balancer Configuration
# Name: {{ load_balancer.name }}

{# Global settings #}
global
    daemon
    maxconn {{ load_balancer.max_connections | default(5000) }}
    log 127.0.0.1 local0 info

{# Defaults section with error checking #}
defaults
    log global
    mode http
    option httplog
    option dontlognull
    timeout connect {{ load_balancer.timeouts.connect | default("5000") }}
    timeout client {{ load_balancer.timeouts.client | default("50000") }}
    timeout server {{ load_balancer.timeouts.server | default("50000") }}
    retries {{ load_balancer.retries | default(3) }}
    
{# Frontend configuration #}
frontend http_front
    bind *:{{ load_balancer.frontend.port }}
    {% if load_balancer.frontend.ssl %}
    bind *:443 ssl crt {{ load_balancer.frontend.ssl_cert }}
    redirect scheme https if !{ ssl_fc }
    {% endif %}
    
    {# ACL definitions #}
    {% for backend in load_balancer.backends %}
    acl is_{{ backend.name }} path_beg -i {{ backend.health_check }}
    {% endfor %}
    
    {# Routing rules #}
    {% for backend in load_balancer.backends %}
    use_backend {{ backend.name }}_backend if is_{{ backend.name }}
    {% endfor %}
    
    default_backend web_backend

{# Backend configurations #}
backend web_backend
    balance roundrobin
    option httpchk GET /health
    
    {# Server entries with validation #}
    {% for backend in load_balancer.backends %}
    {% if backend.address and backend.port %}
    server {{ backend.name }} {{ backend.address }}:{{ backend.port }} weight {{ backend.weight | default(1) }} check inter {{ monitoring.interval | default(30) }}s fall 3 rise 2
    {% else %}
    {# Error handling for missing backend config #}
    # WARNING: Incomplete configuration for {{ backend.name }}
    {% endif %}
    {% endfor %}

{# Monitoring configuration if enabled #}
{% if monitoring.enabled %}
listen stats
    bind *:1936
    stats enable
    stats uri /haproxy?stats
    stats realm Haproxy\ Statistics
    stats auth admin:{{ monitoring.stats_password | default("password") }}
    
    {# Alert configuration #}
    {% if monitoring.alerts %}
    # Alert recipients
    {% for alert in monitoring.alerts %}
    # {{ alert }}
    {% endfor %}
    {% endif %}
{% endif %}

{# Validation and error reporting #}
{% if load_balancer.backends | length == 0 %}
# ERROR: No backends configured!
{% endif %}

{% if not load_balancer.frontend.ssl_cert and load_balancer.frontend.ssl %}
# WARNING: SSL enabled but no certificate specified
{% endif %}
```

### Cheat Sheet: Essential Filters

```jinja2
{# STRING FILTERS #}
{{ string_var | upper }}               {# Convert to uppercase #}
{{ string_var | lower }}               {# Convert to lowercase #}
{{ string_var | capitalize }}          {# Capitalize first letter #}
{{ string_var | replace("old", "new") }} {# Replace substring #}
{{ string_var | regex_replace(pattern, replacement) }}

{# LIST FILTERS #}
{{ list_var | length }}                {# Get list length #}
{{ list_var | first }}                 {# Get first element #}
{{ list_var | last }}                  {# Get last element #}
{{ list_var | join(",") }}             {# Join with delimiter #}
{{ list_var | sort }}                  {# Sort list #}
{{ list_var | unique }}                {# Remove duplicates #}

{# MATH FILTERS #}
{{ number_var | int }}                 {# Convert to integer #}
{{ number_var | float }}               {# Convert to float #}
{{ number_var | abs }}                 {# Absolute value #}
{{ number_var | round }}               {# Round number #}
{{ (bytes | int) / 1048576 }}          {# Convert bytes to MB #}

{# DATA TYPE FILTERS #}
{{ var | default("default_value") }}   {# Provide default #}
{{ var | bool }}                       {# Convert to boolean #}
{{ var | to_json }}                    {# Convert to JSON #}
{{ var | to_yaml }}                    {# Convert to YAML #}

{# SELECTION FILTERS #}
{{ list | selectattr("enabled") }}     {# Filter objects by attribute #}
{{ list | rejectattr("active") }}      {# Exclude objects by attribute #}
{{ list | map(attribute="name") }}     {# Extract attribute values #}

{# COMBINATION FILTERS #}
{{ list | selectattr("active") | map(attribute="name") | join(",") }}
```


[Main](../README.md)
---